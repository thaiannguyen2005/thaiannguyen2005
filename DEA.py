# -*- coding: utf-8 -*-
"""VTBH.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ud_z0UjzuKRUBy9kK_ZHNWaWFeQQ_z-W
"""

# -*- coding: utf-8 -*-
# --- Bước 1: Import thư viện và chuẩn bị dữ liệu ---
import pandas as pd
import numpy as np
from scipy.optimize import linprog
from scipy.stats import pearsonr

# Dữ liệu của 3 cảng trong 5 năm
data = {
    'DMUs': ['2020-A', '2021-A', '2022-A', '2023-A', '2024-A',
             '2020-B', '2021-B', '2022-B', '2023-B', '2024-B',
             '2020-C', '2021-C', '2022-C', '2023-C', '2024-C'],
    'x1': [56, 56, 56, 56, 56, 28, 28, 28, 28, 28, 42, 42, 42, 42, 42],
    'x2': [5, 5, 5, 5, 5, 8, 8, 8, 8, 8, 0, 0, 0, 0, 0],
    'x3': [400, 400, 400, 400, 400, 425, 425, 425, 425, 425, 150, 150, 150, 150, 150],
    'x4': [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 15, 15, 15, 15, 15],
    'x5': [188.29, 135.98, 142.23, 147.63, 220.81, 188.29, 206.67, 185.85, 216.18, 249.77, 109.88, 119.87, 194.15, 236.20, 350.89],
    'x6': [602.05, 530.94, 449.96, 528.56, 646.07, 268.77, 289.21, 274.42, 321.63, 367.43, 441.10, 414.34, 646.25, 644.22, 867.85],
    'y': [650000, 760000, 740000, 800000, 872000, 558764, 601096, 556304, 491943, 573124, 346000, 421000, 419216, 430000, 605900]
}
df = pd.DataFrame(data).set_index('DMUs')

# Chuyển dữ liệu sang dạng mảng numpy để tính toán
inputs = df[['x1', 'x2', 'x3', 'x4', 'x5', 'x6']].values
outputs = df[['y']].values
dmu_names = df.index.values
n_dmus, n_inputs = inputs.shape
_, n_outputs = outputs.shape

# --- Bước 2: Xây dựng các hàm giải DEA ---

def find_alternative_peers(dmu_k_idx, inputs, outputs):
    """
    Hàm này kiểm tra xem một DMU hiệu quả có các peer thay thế hay không.
    Nó thử biểu diễn DMU_k bằng tổ hợp của các DMU khác.
    """
    # Biến là lambdas cho tất cả DMUs
    c = np.zeros(n_dmus)  # Hàm mục tiêu không quan trọng, chỉ cần tìm nghiệm

    # Ràng buộc: sum(lambda_j * x_j) <= x_k
    A_ub_inputs = inputs.T
    b_ub_inputs = inputs[dmu_k_idx, :]

    # Ràng buộc: sum(lambda_j * y_j) >= y_k  => -sum(lambda_j * y_j) <= -y_k
    A_ub_outputs = -outputs.T
    b_ub_outputs = -outputs[dmu_k_idx, :]

    A_ub = np.vstack([A_ub_inputs, A_ub_outputs])
    b_ub = np.concatenate([b_ub_inputs, b_ub_outputs])

    # Ràng buộc: sum(lambda_j) = 1
    A_eq = np.ones((1, n_dmus))
    b_eq = np.array([1])

    # Ràng buộc quan trọng: lambda cho chính DMU đang xét phải BẰNG 0
    bounds = [(0, None)] * n_dmus
    bounds[dmu_k_idx] = (0, 0)

    result = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')

    if result.success and result.status == 0:
        peer_indices = np.where(result.x > 1e-5)[0]
        if len(peer_indices) > 0:
            return peer_indices  # Trả về danh sách peer thay thế
    return None # Không tìm thấy nghiệm thay thế

def solve_dea_envelopment(inputs, outputs, model='ccr'):
    results = []
    for i in range(n_dmus):
        c = np.zeros(1 + n_dmus); c[0] = 1
        A_ub_inputs = np.hstack([(-inputs[i, :]).reshape(-1, 1), inputs.T])
        b_ub_inputs = np.zeros(n_inputs)
        A_ub_outputs = np.hstack([np.zeros((n_outputs, 1)), -outputs.T])
        b_ub_outputs = -outputs[i, :]
        A_ub = np.vstack([A_ub_inputs, A_ub_outputs]); b_ub = np.concatenate([b_ub_inputs, b_ub_outputs])
        A_eq, b_eq = None, None
        if model.lower() == 'bcc':
            A_eq = np.ones((1, 1 + n_dmus)); A_eq[0, 0] = 0; b_eq = np.array([1])
        bounds = [(None, 1)] + [(0, None)] * n_dmus
        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs')
        if res.success:
            score = res.fun; lambdas = res.x[1:]
            s_minus = score * inputs[i, :] - np.dot(lambdas, inputs)
            s_plus = np.dot(lambdas, outputs) - outputs[i, :]
            results.append({'score': score, 'lambdas': lambdas, 'sum_lambdas': np.sum(lambdas), 's_minus': s_minus, 's_plus': s_plus})
        else:
            results.append({'score': np.nan, 'lambdas': np.full(n_dmus, np.nan), 'sum_lambdas': np.nan, 's_minus': np.full(n_inputs, np.nan), 's_plus': np.full(n_outputs, np.nan)})
    return results


def solve_dea_multiplier(inputs, outputs, model='ccr'):
    results = []
    for i in range(n_dmus):
        # Objective function: maximize u*y_i - sum(v*x_i)
        c = np.concatenate([-outputs[i, :], inputs[i, :]])

        # Constraints: u*y_j - sum(v*x_j) <= 0 for all j
        # Need n_dmus constraints, each with n_outputs + n_inputs variables (u and v)
        A_ub = np.zeros((n_dmus, n_outputs + n_inputs))
        for j in range(n_dmus):
            A_ub[j, :n_outputs] = outputs[j, :]  # Coefficients for u (outputs)
            A_ub[j, n_outputs:] = -inputs[j, :] # Coefficients for v (inputs)

        b_ub = np.zeros(n_dmus)

        # Normalization constraint (e.g., sum(v*x_i) = 1 or u*y_i = 1)
        A_eq, b_eq = None, None
        if model.lower() == 'ccr':
             # For CCR, sum(v*x_i) = 1
             A_eq = np.concatenate([np.zeros(n_outputs), inputs[i, :]]).reshape(1, -1)
             b_eq = np.array([1])
        elif model.lower() == 'bcc':
            # For BCC, sum(v*x_i) - u0 = 1 (where u0 is the variable for convexity)
            # This formulation is slightly different and requires an additional variable u0.
            # For simplicity and consistency with the original code's output tables,
            # we will stick to the CCR multiplier formulation for now, which aligns with the OE scores.
            # If BCC multipliers are needed, the formulation would need adjustment to include u0.
             A_eq = np.concatenate([np.zeros(n_outputs), inputs[i, :]]).reshape(1, -1)
             b_eq = np.array([1])


        # Bounds: u >= epsilon, v >= epsilon (epsilon is a small positive number to avoid zero weights)
        epsilon = 1e-6
        bounds = [(epsilon, None)] * (n_outputs + n_inputs)

        res = linprog(c, A_ub=A_ub, b_ub=b_ub, A_eq=A_eq, b_eq=b_eq, bounds=bounds, method='highs', options={'presolve': True}) # Added presolve

        if res.success:
            multipliers = res.x
            results.append(multipliers)
        else:
            results.append(np.full(n_outputs + n_inputs, np.nan))
    return np.array(results)


def run_correlation_analysis(df_data):
    print("\nBẢNG PHÂN TÍCH TƯƠNG QUAN (CORRELATION ANALYSIS)\n")
    input_cols = [col for col in df_data.columns if col.startswith('x')]; output_col = 'y'
    corr_results = {}
    for in_col in input_cols:
        corr, p_value = pearsonr(df_data[in_col], df_data[output_col])
        corr_str = f"{corr:.3f}{'*' if p_value < 0.01 else ''}"; corr_results[in_col] = corr_str
    df_corr = pd.DataFrame(corr_results, index=[output_col])
    print(df_corr.to_string()); print("Ghi chú: * p < 0.01"); print("="*65)

# --- Bước 3: Chạy các mô hình và hiển thị tuần tự các bảng ---
print("Đang tính toán...")
run_correlation_analysis(df)

ccr_results = solve_dea_envelopment(inputs, outputs, model='ccr')
bcc_results = solve_dea_envelopment(inputs, outputs, model='bcc')
all_multipliers = solve_dea_multiplier(inputs, outputs, model='ccr') # Calculate multipliers


oe_scores = np.array([res['score'] for res in ccr_results])
te_scores = np.array([res['score'] for res in bcc_results])
se_scores = np.divide(oe_scores, te_scores, out=np.zeros_like(oe_scores), where=te_scores!=0)

#  Lấy thông tin Peers và RTS
peers_list = []
rts_list = []
for i in range(n_dmus):
    # Xác định Peers
    is_te_efficient = abs(te_scores[i] - 1.0) < 1e-5
    if is_te_efficient:
        # Nếu hiệu quả, tìm peer thay thế
        alternative_peers = find_alternative_peers(i, inputs, outputs)
        if alternative_peers is not None:
            peers_list.append(', '.join(dmu_names[alternative_peers]))
        else:
            # Nếu không có peer thay thế, nó là peer của chính nó
            peers_list.append(dmu_names[i])
    else:
        # Nếu không hiệu quả, tìm peer từ kết quả BCC ban đầu
        peer_indices = np.where(bcc_results[i]['lambdas'] > 1e-5)[0]
        peers_list.append(', '.join(dmu_names[peer_indices]))

    # Xác định Return-to-Scale từ tổng lambda của mô hình CCR
    sum_lambda_ccr = ccr_results[i]['sum_lambdas']
    if abs(sum_lambda_ccr - 1.0) < 1e-5: rts_list.append("Constant")
    elif sum_lambda_ccr < 1.0: rts_list.append("Increasing")
    else: rts_list.append("Decreasing")

input_slacks = np.array([res['s_minus'] for res in ccr_results])
output_slacks = np.array([res['s_plus'] for res in ccr_results])

print("Hoàn tất!\n"); print("="*65)

# --- BẢNG KẾT QUẢ TỔNG HỢP
print("\nBẢNG TỔNG HỢP ĐIỂM HIỆU QUẢ\n")
df_results = pd.DataFrame({
    'OE (Overall E.)': oe_scores,
    'Peers': peers_list,
    'TE (Technical E.)': te_scores,
    'SE (Scale E.)': se_scores,
    'Return-to-Scale': rts_list
}, index=df.index)

df_results = df_results[['OE (Overall E.)', 'Peers', 'TE (Technical E.)', 'SE (Scale E.)', 'Return-to-Scale']]

# === DÒNG MỚI THÊM VÀO ĐỂ GỘP BẢNG ===
pd.set_option('display.width', None)
# =======================================

print(df_results.round(4))
print("="*65)
# --- Hiển thị Bảng 7: The multipliers of the inputs and the output ---
print("\nBẢNG: CÁC TRỌNG SỐ TỐI ƯU (MULTIPLIERS)\n")
input_multipliers = all_multipliers[:, :n_inputs]
output_multipliers = all_multipliers[:, n_inputs:]
df_table7 = pd.DataFrame(
    np.hstack([
        oe_scores.reshape(-1, 1),
        input_multipliers,
        output_multipliers
    ]),
    index=df.index,
    columns=['OE (h*)', 'v1*', 'v2*', 'v3*', 'v4*', 'v5*', 'v6*', 'u*']
)
print(df_table7.round(4).fillna(0))
print("="*65)
# --- Hiển thị Bảng 8: The result of slack variable analysis ---
print("\nBẢNG: KẾT QUẢ PHÂN TÍCH BIẾN BÙ (SLACK VARIABLES)\n")
df_table8 = pd.DataFrame(
    np.hstack([
        oe_scores.reshape(-1, 1),
        input_slacks,
        output_slacks
    ]),
    index=df.index,
    columns=['OE', 'S1-', 'S2-', 'S3-', 'S4-', 'S5-', 'S6-', 'S+']
)
print(df_table8.round(3))
print("="*65)

# --- Hiển thị Bảng 9: Tính giá trị tối ưu cho các DMU được yêu cầu ---
print("\nBẢNG: VÍ DỤ TÍNH TOÁN GIÁ TRỊ ĐẦU VÀO TỐI ƯU\n")
dmus_to_project = ['2024-A', '2024-B', '2024-C']
for dmu_name in dmus_to_project:
    print(f"--- Phân tích cho DMU: {dmu_name} ---\n")
    dmu_idx = df.index.get_loc(dmu_name)
    initial_values = df.loc[dmu_name, :].values
    h_star = oe_scores[dmu_idx]
    slacks_dmu = input_slacks[dmu_idx, :]
    optimal_inputs = h_star * initial_values[:n_inputs] - slacks_dmu
    optimal_output = initial_values[n_inputs:] + output_slacks[dmu_idx, :]
    revisions = np.append(optimal_inputs, optimal_output) - initial_values
    percentages = np.divide(revisions, initial_values, out=np.zeros_like(revisions), where=initial_values!=0) * 100
    df_projection = pd.DataFrame({
        'Input item': ['x1', 'x2', 'x3', 'x4', 'x5', 'x6', 'y'],
        'Initial values': initial_values,
        'Optimal values': np.append(optimal_inputs, optimal_output),
        'Revisions': revisions,
        '%': [f"{p:.2f}%" for p in percentages]
    }).set_index('Input item')
    pd.options.display.float_format = '{:,.3f}'.format
    print(df_projection)
    pd.reset_option('display.float_format')
    print("\n" + "-"*40 + "\n")
print("="*65)

# --- Hiển thị Bảng 10: The summation of DMUs' overall efficiency score ---
print("\nBẢNG: TỔNG HỢP ĐIỂM HIỆU QUẢ TỔNG THỂ CỦA CÁC DMU\n")
df_summary = pd.DataFrame({'OE': oe_scores}, index=df.index)
df_summary['Operator'] = df_summary.index.str.split('-').str[1]
df_summary['Year'] = df_summary.index.str.split('-').str[0]
pivot_table = df_summary.pivot_table(index='Operator', columns='Year', values='OE')
summary_stats = pd.DataFrame(index=pivot_table.index)
summary_stats['Mean'] = pivot_table.mean(axis=1)
summary_stats['Variation'] = pivot_table.var(axis=1)
summary_stats['Range'] = pivot_table.max(axis=1) - pivot_table.min(axis=1)
summary_stats['Rank'] = summary_stats['Mean'].rank(ascending=False, method='min').astype(int)
df_table10 = pivot_table.join(summary_stats)
df_table10 = df_table10.sort_values('Rank')
print(df_table10.round(5))
print("="*65)

